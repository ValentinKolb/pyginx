#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess

# remote dependencies
import validators
from jinja2 import BaseLoader, Environment

# set up templating engine environment
jinja_env = Environment(loader=BaseLoader(),
                        lstrip_blocks=True,
                        trim_blocks=True)

http_template = """# [ debug | info | notice | warn | error | crit ]
error_log  /var/log/{{ domain }}.nginx.error_log  warn;

http {
    upstream backend {
        {% for upstream in upstreams %}
        server {{ upstream }};
        {% endfor %}
    }

    server {
        server_name {{ domain }};
        listen      80;
        listen      [::]:80;

        location / {
            proxy_pass http://backend;
        }
    }
}
"""

stream_template = """# [ debug | info | notice | warn | error | crit ]
error_log  /var/log/stream_{{ port }}.nginx.error_log  warn;
stream {
    upstream backend {
        {% for upstream in upstreams %}
        server {{ upstream }};
        {% endfor %}
    }
    server {
          listen        {{ port }};
          proxy_pass    upstream; 
     }
}
"""


def domain(d: str) -> str:
    """
    validates a string to be a domain name or an IPv4 oder IPv6

    Parameters
    ----------
    d : str
        the string to be validated

    Returns
    -------
    bool :
        the domain
    """
    if any([d == 'localhost',
            validators.domain(d),
            validators.ipv4(d),
            validators.ipv6(d)]):
        return d
    raise argparse.ArgumentTypeError(f'{d}: must be a valid dns name, IPv4 or IPv6')


def port(p: str) -> str:
    """
    checks if an string is a network port

    Parameters
    ----------
    p : str
        will be check

    Returns
    -------
    str :
        the port if it is a positive integer between 1 and 65535, False otherwise
    """
    if p.isnumeric() and 1 <= int(p) <= 65535:
        return p
    raise argparse.ArgumentTypeError(f'{p}: must be a positive integer between 1 and 65535')


def upstream(u: str):
    """
    validates a upstream

    Parameters
    ----------
    u : str
        will be validated
    """
    d, p = u.split(":", 1)
    domain(d)
    port(p)
    return u



if not os.geteuid() == 0:
    print("You must run this script as root", file=sys.stderr)
    exit(1)

# create the top-level parser
parser = argparse.ArgumentParser(
    prog='pyginx',
    description='Python script to automate nginx virtual server and stream deployment.'
)
parser.add_argument('--version', action='version', version='%(prog)s 1.0')
subparsers = parser.add_subparsers(help="run 'pyginx <command> -h' for more info", required=True, dest="usage")

# create the parser for the "http" command
http_parser = subparsers.add_parser('http', help='creates a new config file for an http virtual server')

# required http arguments
http_parser_required = http_parser.add_argument_group("required")
http_parser_required.add_argument('-d', '--Domain',
                                  metavar="",
                                  type=domain,
                                  help='help for bar, positional',
                                  required=True)
http_parser_required.add_argument('--Upstream', '-u',
                                  metavar="",
                                  action="append",
                                  nargs="+",
                                  type=upstream,
                                  help='the upstream and port where the connection is forwarded to. '
                                       'format: <domain/ip>:<port>',
                                  required=True)

# optional http arguments
http_parser.add_argument("--no-ssl",
                         action="store_false",
                         default=True,
                         help="don't automatically run certbot to request a ssl certificate and enable https")

# create the parser for the "stream" command
stream_parser = subparsers.add_parser('stream', help='creates a config file for an tcp stream')
# required stream arguments
stream_parser_required = stream_parser.add_argument_group("required")
stream_parser_required.add_argument('--Upstream', '-u',
                                    metavar="",
                                    action="append",
                                    nargs="+",
                                    type=upstream,
                                    help='the upstream and port where the connection is forwarded to. '
                                         'format: <domain/ip>:<port>',
                                    required=True)
stream_parser_required.add_argument('--Port', '-p',
                                    metavar="",
                                    type=port,
                                    help='the port that should be forwarded',
                                    required=True)

args = parser.parse_args()

filename = rendered_template = ""

if args.usage == "http":
    filename = f"{args.Domain}.conf"
    rendered_template = jinja_env.from_string(http_template).render(
        domain=args.Domain,
        upstreams=args.Upstream
    )

elif args.usage == "stream":
    filename = f"{args.Port}.conf"
    rendered_template = jinja_env.from_string(stream_template).render(
        prot=args.Port,
        upstreams=args.Upstream
    )
else:
    exit(-1)

path = f"/etc/nginx/conf.d/http/{filename}"
if os.path.isfile(path):
    if not "y" == input(
            f"The file {filename} already exists,"
            f" do you want to override it? [y/n] : ").strip().lower():
        exit(2)

# write to config file
with open(path, "w+") as file:
    file.write(rendered_template)

# run certbot accordingly
if args.usage == "http" and not args.no_ssl:
    return_code = subprocess.call(["sudo", "certbot", "--nginx", "-d", args.Domain])
    if return_code != 0:
        exit(return_code)

print("The configfile was generated.")
print("After that the file will be automatically opened in 'nano' for further adjustments.")
input("Press ENTER to continue.")

subprocess.call(["sudo", "nano", path])
if 0 != subprocess.call(["sudo", "nginx", "-t"]):
    print(f"The config file contains invalid syntax. Location of the file : {path}", file=sys.stderr)
    print("To reload nginx after the fix run 'sudo systemctl reload nginx'")
    exit(3)

subprocess.call(["sudo", "systemctl", "reload", "nginx"])
print("Configuration successfully deployed!")
print(f"Config file: {path}")
