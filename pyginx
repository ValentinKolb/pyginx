#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import re

from os import listdir
from os.path import isfile, join
from dataclasses import dataclass

# remote dependencies
from typing import Optional, Union

import validators
from jinja2 import FileSystemLoader, Environment
from configparser import ConfigParser, ExtendedInterpolation

VERSION = '1.7.0'

# creating parser for config file
config_file = ConfigParser(interpolation=ExtendedInterpolation())


# datatype's
def wrong_argument(message: str):
    raise argparse.ArgumentTypeError(message)


domain = lambda d: d if any([d == 'localhost',
                             validators.domain(d),
                             validators.ipv4(d),
                             validators.ipv6(d)]) \
    else wrong_argument(f'{d}: must be a valid dns name, IPv4 or IPv6')

port = lambda p: p if p.isnumeric() and 1 <= int(p) <= 65535 \
    else wrong_argument(f'{p}: must be a positive integer between 1 and 65535')

upstream = lambda u: u if domain(u.split(":", 1)[0]) and port(u.split(":", 1)[1]) else None

backend_name = lambda b: b if re.match(r'^[a-zA-z0-9_]+$', b) or b is None \
    else wrong_argument(f'{b}: str can only contain letters, number and underscores')

forward_scheme = lambda s: s if s in ('http', 'https') \
    else wrong_argument(f'{s}: must be either http or https')

label = lambda s: s if True else argparse.ArgumentTypeError(f'{s}: must be either http or https')


@dataclass(frozen=True)
class Data:
    """
    base template data class
    """
    list_info: str
    label: str
    backend_name: backend_name
    upstreams: list[upstream]


@dataclass(frozen=True)
class HTTPData(Data):
    """
    stores all data for the http template
    """
    domain: domain
    forward_scheme: forward_scheme


@dataclass(frozen=True)
class StreamData(Data):
    """
    stores all data for the stream template
    """
    port: port


def deploy_config(template: str, data: Union[HTTPData, StreamData], path: str, args: argparse.Namespace):
    """
    renders template and deploys it
    Parameters
    ----------
    template : str
        the name of the template
    data : HTTPData, StreamData
        the data for the template
    path : str
        the path where to save the config
    args : Namespace
        the current argparse namespace
    """
    rendered_template = jinja_env.get_template(template).render(data=data)

    if args.mock:
        print("Generated config:")
        print(rendered_template)
        exit(0)

    if os.path.isfile(path):
        if not "y" == input(
                f"The file {filename} already exists,"
                f" do you want to override it? [y/n] : ").strip().lower():
            exit(2)

    # write to config file
    if not quiet:
        print(f"Saving config file to {path!r}")
    with open(path, "w+") as file:
        file.write(rendered_template)

    # run certbot accordingly
    if args.usage == "http" and not args.no_ssl and not args.mock:
        return_code = subprocess.call(["sudo", "certbot", "--nginx", "-d", args.domain])
        if return_code != 0:
            exit(return_code)

    if not quiet:
        print("The config file was generated.")
        print("The file will be automatically opened in 'nano' for further adjustments.")
    input("Press ENTER to continue.")

    edit_config_file(path)


def edit_config_file(path):
    """
    opens the file in $EDITOR (default is nano not set)
    after the file was saved and if ``nginx -t`` was successfully nginx is reloaded

    Parameters
    ----------
    path : str
        the path of the file to be edited
    """
    subprocess.call(["sudo", os.getenv("$EDITOR", "nano"), path])
    if 0 != subprocess.call(["sudo", "nginx", "-t"]):
        print(f"The config file contains invalid syntax. Location of the file : {path}", file=sys.stderr)
        print("To reload nginx after the fix run 'sudo systemctl reload nginx'")
        exit(3)
    else:
        subprocess.call(["sudo", "systemctl", "reload", "nginx"])
        print("Configuration successfully deployed!")
        print(f"Config file: {path}")


def list_config():
    """
    prints the all config files and extracts additional information if possible
    """
    files = config_files()
    print("Configuration:")
    for file in files:
        with open(file) as f:
            for line in f.readlines():
                if match := re.match(r'^# list_info: (?P<list_info>.*)$', line):
                    print(f'{file} => {match.group("list_info")}')
                else:
                    print(file)


def config_files():
    """
    Returns
    -------
    list :
        all the config files
    """
    files = [join(nginx_http_dir, f) for f in listdir(nginx_http_dir) if isfile(join(nginx_http_dir, f))
             and f.endswith(".conf")]
    files += [join(nginx_stream_dir, f) for f in listdir(nginx_stream_dir) if isfile(join(nginx_stream_dir, f))
              and f.endswith(".conf")]
    return files


if __name__ == '__main__':
    # create the top-level parser
    argument_parser = argparse.ArgumentParser(
        prog='pyginx',
        description='Python script to automate nginx virtual server and stream deployment.'
    )
    argument_parser.add_argument('--version', action='version', version=f'%(prog)s {VERSION}', help="Show version.")
    argument_parser.add_argument('--config-file', metavar="", type=str, default="/etc/pyginx.d/pyginx.ini",
                                 help="The path of the pyginx config file.")

    argument_parser.add_argument('--label', metavar="", type=str, default=None,
                                 help="This label is used for the filename of the configuration and log "
                                      "file and for the name of the backend. "
                                      "The default value is the domain for 'http' and the public port for 'stream'")
    argument_parser.add_argument("--mock",
                                 action="store_true",
                                 default=False,
                                 help="Run script in mock mode. "
                                      "In this mode the config is not saved and nginx is not reloaded. "
                                      "Certbot will also not be run.")

    # option for verbose and quiet output
    verbose_quiet_group = argument_parser.add_mutually_exclusive_group()
    verbose_quiet_group.add_argument("--verbose",
                                     action="store_true",
                                     default=False,
                                     help="Verbose output.")
    verbose_quiet_group.add_argument("--quiet",
                                     action="store_true",
                                     default=False,
                                     help="Minimal output.")

    subparsers = argument_parser.add_subparsers(help="run 'pyginx <usage> -h' for more info", required=True,
                                                dest="usage")

    # create the parser for the "http" command
    http_parser = subparsers.add_parser('http', help='Run this command to create a new '
                                                     'config file for an http virtual server')

    # required http arguments
    http_parser_required = http_parser.add_argument_group("required")
    http_parser_required.add_argument('-d', '--domain',
                                      metavar="",
                                      type=domain,
                                      help='The domain under which the service is reachable.'
                                           ' This must be a fully qualified domain name. (e.g. example.com)',
                                      required=True)
    http_parser_required.add_argument('--upstreams', '-u',
                                      metavar="",
                                      nargs="+",
                                      type=upstream,
                                      help='The upstream and port where the connection is forwarded to. '
                                           'Separate multiple upstreams by spaces. '
                                           'Format: <domain/ip>:<port>',
                                      required=True)

    # optional http arguments
    http_parser.add_argument('--backendName', '-b',
                             metavar="",
                             type=backend_name,
                             help="The name of the backend. The default value is 'backend_<label/domain>'",
                             default=None,
                             required=False)
    http_parser.add_argument('--forwardScheme',
                             metavar="",
                             type=forward_scheme,
                             help="The forward scheme for the backend. Must be 'http' (default) or 'https'",
                             default="http",
                             required=False)
    http_parser.add_argument("--no-ssl",
                             action="store_true",
                             default=False,
                             help="Disable SSL: prevent to automatically run certbot "
                                  "to request a ssl certificate and enable https")

    # create the parser for the "stream" command
    stream_parser = subparsers.add_parser('stream', help='Created a new config file for a '
                                                         'tcp stream (i.e port-forwarding). '
                                                         'For this the port on this server must '
                                                         'be exposed by the firewall')
    # required stream arguments
    stream_parser_required = stream_parser.add_argument_group("required")
    stream_parser_required.add_argument('--upstreams', '-u',
                                        metavar="",
                                        nargs="+",
                                        type=upstream,
                                        help='The upstream and port where the connection is forwarded to. '
                                             'Separate multiple upstreams by spaces. '
                                             'Format: <domain/ip>:<port>',
                                        required=True)
    stream_parser_required.add_argument('--port', '-p',
                                        metavar="",
                                        type=port,
                                        help='The port that to be forwarded.',
                                        required=True)

    # optional stream arguments
    stream_parser.add_argument('--backendName', '-b',
                               metavar="",
                               type=backend_name,
                               help="The name of the backend. The default value is 'backend_<label/port>'",
                               default=None,
                               required=False)

    # create parser for the list command
    list_parser = subparsers.add_parser('list', help='Run this command to list all existing configs.')

    # create parser for the list command
    edit_parser = subparsers.add_parser('edit', help='Run this command to edit a configuration '
                                                     'and reload nginx automatically')
    edit_parser.add_argument("file", help="The name of the file to be edited. pyginx will look inside the directories "
                                          "for the nginx config files as specified in the pyginx config file.")

    # parse command line arguments
    args = argument_parser.parse_args()

    # output level
    verbose: bool = args.verbose
    quiet: bool = args.quiet

    # check if script is run as root
    if not args.mock and not os.geteuid() == 0:
        print("You must run this script as root", file=sys.stderr)
        exit(1)

    if verbose:
        print("Run with arguments: ")
        print('\n'.join(f'{k}={v}' for k, v in vars(args).items()))
        print()

    # parse the config file
    config_file.read(args.config_file)
    template_path: str = config_file["templates"]["path"]
    http_template: str = config_file["templates"]["http"]
    stream_template: str = config_file["templates"]["stream"]
    nginx_http_dir: str = config_file["nginx"]["http"]
    nginx_stream_dir: str = config_file["nginx"]["stream"]

    # set up templating engine environment
    jinja_env = Environment(loader=FileSystemLoader(template_path),
                            lstrip_blocks=True,
                            trim_blocks=True)

    # initialise variables
    filename = rendered_template = path = template = ""
    data: Optional[Union[HTTPData, StreamData]] = None

    if args.usage == "http":
        list_info = f'{"http://" if args.no_ssl else "https://"}{args.domain} -> {args.forwardScheme}:// ( {" | ".join(args.upstreams)} )'
        if not quiet:
            print(f'Creating config for: {list_info}')

        filename = f"{args.label}.conf" if args.label else f"{args.domain}.conf"
        label = f'{args.label if args.label else args.domain}'.strip()

        deploy_config(template=http_template,
                      data=HTTPData(
                          list_info=list_info,
                          domain=args.domain,
                          upstreams=args.upstreams,
                          label=label,
                          backend_name=args.backendName if args.backendName else f'backend_{label}',
                          forward_scheme=args.forwardScheme
                      ), path=f"{nginx_http_dir}/{filename}",
                      args=args)

    elif args.usage == "stream":
        list_info = f'0.0.0.0:{args.port} -> ( {" | ".join(args.upstreams)} )'
        if not quiet:
            print(f'Creating config for: {list_info}')

        filename = f"{args.label}.conf" if args.label else f"{args.port}.conf"
        label = f'{args.label if args.label else args.port}'.strip()

        deploy_config(template=stream_template,
                      data=StreamData(
                          list_info=list_info,
                          port=args.port,
                          upstreams=args.upstreams,
                          label=label,
                          backend_name=args.backendName if args.backendName else f'backend_{label}'
                      ), path=f"{nginx_stream_dir}/{filename}",
                      args=args)

    elif args.usage == "list":

        list_config()

    elif args.usage == "edit":
        file = args.file if args.file.endswith(".conf") else args.file + ".conf"
        for conf_file in config_files():
            if re.match(rf'.*/{file}', conf_file):
                edit_config_file(conf_file)
                break
        else:
            print("File not found!", file=sys.stderr)
            exit(4)



    else:
        exit(-1)
