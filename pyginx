#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import re

from os import listdir
from os.path import isfile, join
from dataclasses import dataclass

# remote dependencies
from typing import Optional, Union, NewType, Literal

import validators
from jinja2 import FileSystemLoader, Environment
from configparser import ConfigParser, ExtendedInterpolation

VERSION = '1.7.0'


##
# SPECIAL DATA TYPES
##
def wrong_argument(message: str):
    raise argparse.ArgumentTypeError(message)


domain = lambda d: d if any([d == 'localhost',
                             validators.domain(d),
                             validators.ipv4(d),
                             validators.ipv6(d)]) \
    else wrong_argument(f'{d}: must be a valid dns name, IPv4 or IPv6')

port = lambda p: p if p.isnumeric() and 1 <= int(p) <= 65535 \
    else wrong_argument(f'{p}: must be a positive integer between 1 and 65535')

upstream = lambda u: u if domain(u.split(":", 1)[0]) and port(u.split(":", 1)[1]) \
    else None

backend_name = lambda b: b if re.match(r'^[a-zA-z0-9_]+$', b) or b is None \
    else wrong_argument(f'{b}: str can only contain letters, number and underscores')

forward_scheme = lambda s: s if s in ('http', 'https') \
    else wrong_argument(f'{s}: must be either http or https')

label = lambda s: s if True \
    else argparse.ArgumentTypeError(f'{s}: must be either http or https')

##
# ARGUMENT PARSER
##
# create the top-level parser
argument_parser = argparse.ArgumentParser(
    prog='pyginx',
    description='Python script to automate nginx virtual server and stream deployment.'
)
argument_parser.add_argument('--version', action='version', version=f'%(prog)s {VERSION}',
                             help="Show version and exit.")
argument_parser.add_argument('--config-file', metavar="", type=str, default="/etc/pyginx.d/pyginx.ini",
                             help="The path of the pyginx config file.")

argument_parser.add_argument('--label', metavar="", type=str, default=None,
                             help="This label is used for the filename of the configuration and log "
                                  "file and for the name of the backend. "
                                  "The default value is the domain for 'http' and the public port for 'stream'")
argument_parser.add_argument("--mock",
                             action="store_true",
                             default=False,
                             help="Run script in mock mode. "
                                  "In this mode the config is not saved but printed to the terminal. "
                                  "Neither nginx nor certbot will be run.")

# option for verbose and quiet output
verbose_quiet_group = argument_parser.add_mutually_exclusive_group()
verbose_quiet_group.add_argument("--verbose",
                                 action="store_true",
                                 default=False,
                                 help="Verbose output.")
verbose_quiet_group.add_argument("--quiet",
                                 action="store_true",
                                 default=False,
                                 help="Minimal output.")

subparsers = argument_parser.add_subparsers(help="run 'pyginx <usage> -h' for more info", required=True,
                                            dest="usage")

# create the parser for the "http" command
http_parser = subparsers.add_parser('http', help='Run this command to create a new '
                                                 'config file for an http virtual server')

# required http arguments
http_parser_required = http_parser.add_argument_group("required")
http_parser_required.add_argument('-d', '--domain',
                                  metavar="",
                                  type=domain,
                                  help='The domain under which the service is reachable.'
                                       ' This must be a fully qualified domain name. (e.g. example.com)',
                                  required=True)
http_parser_required.add_argument('--upstreams', '-u',
                                  metavar="",
                                  nargs="+",
                                  type=upstream,
                                  help='The upstream and port where the connection is forwarded to. '
                                       'Separate multiple upstreams by spaces. '
                                       'Format: <domain/ip>:<port>',
                                  required=True)

# optional http arguments
http_parser.add_argument('--backendName', '-b',
                         metavar="",
                         type=backend_name,
                         help="The name of the backend. The default value is 'backend_<label/domain>'",
                         default=None,
                         required=False)
http_parser.add_argument('--forwardScheme',
                         metavar="",
                         type=forward_scheme,
                         help="The forward scheme for the backend. Must be 'http' (default) or 'https'",
                         default="http",
                         required=False)
http_parser.add_argument("--no-ssl",
                         action="store_true",
                         default=False,
                         help="Disable SSL: prevent to automatically run certbot "
                              "to request a ssl certificate and enable https")

# create the parser for the "stream" command
stream_parser = subparsers.add_parser('stream', help='Created a new config file for a '
                                                     'tcp stream (i.e port-forwarding). '
                                                     'For this the port on this server must '
                                                     'be exposed by the firewall')
# required stream arguments
stream_parser_required = stream_parser.add_argument_group("required")
stream_parser_required.add_argument('--upstreams', '-u',
                                    metavar="",
                                    nargs="+",
                                    type=upstream,
                                    help='The upstream and port where the connection is forwarded to. '
                                         'Separate multiple upstreams by spaces. '
                                         'Format: <domain/ip>:<port>',
                                    required=True)
stream_parser_required.add_argument('--port', '-p',
                                    metavar="",
                                    type=port,
                                    help='The port that to be forwarded.',
                                    required=True)

# optional stream arguments
stream_parser.add_argument('--backendName', '-b',
                           metavar="",
                           type=backend_name,
                           help="The name of the backend. The default value is 'backend_<label/port>'",
                           default=None,
                           required=False)

# create parser for the list command
list_parser = subparsers.add_parser('list', help='Run this command to list all existing configs.')

# create parser for the list command
edit_parser = subparsers.add_parser('edit', help='Run this command to edit a configuration '
                                                 'and reload nginx automatically')
edit_parser.add_argument("file", help="The name of the file to be edited. pyginx will look inside the directories "
                                      "for the nginx config files as specified in the pyginx config file.")

##
# CONFIG FILE PARSER
##
config_file = ConfigParser(interpolation=ExtendedInterpolation())


##
# DATACLASSES FOR STORING TEMPLATE DATA
##
@dataclass(frozen=True)
class Data:
    """
    base template data class
    """
    list_info: str
    label: str
    backend_name: backend_name
    upstreams: list[upstream]


@dataclass(frozen=True)
class HTTPData(Data):
    """
    stores all data for the http template
    """
    domain: domain
    forward_scheme: forward_scheme


@dataclass(frozen=True)
class StreamData(Data):
    """
    stores all data for the stream template
    """
    port: port


##
# HELPER FUNCTIONS
##

YES = "YES"
NO = "NO"

MODE = Literal["not-quiet", "verbose", "always"]
STYLE = Optional[Literal["success", "error", "bold"]]


def output(message: str, mode: MODE = "always", file=sys.stdout, style: STYLE = None):
    """
    prints message to the console
    the message will only be printed, if the mode matches the mode specified in argparse

    Parameters
    ----------
    message : str
        will be printed
    mode : MODE
        either not-quiet, verbose or always
    file :
        same as print(file=..)
    style : STYLE
        the style of the output, None for no special style
    """
    reset = u'\u001b[0m'
    green = u'\u001b[32m'
    red = u'\u001b[31m'
    bold = u'\u001b[1m'
    if mode == "not-quiet" and not args.quiet or mode == "verbose" and args.verbose or mode == "always":
        if style == "success":
            message = f'✔ {green}{message}{reset}'
        elif style == "error":
            message = f'✗ {red}{message}{reset}'
        elif style == "bold":
            message = f'{bold}{message}{reset}'
        print(message, file=file)


def yes_or_no(message: str, default: Optional[Literal["YES", "NO"]] = YES) -> Literal["YES", "NO"]:
    """
    prompt user for yes or no question

    Parameters
    ----------
    message :
        will be printed to inform the suer about the question
    default :
        either YES, NO or None. this value will be returned, if the user enters nothing.
        if None, the user will be prompted until something valid is entered

    Returns
    -------
    str :
        the answer
    """
    output(f"{message.strip()} {'[Y/n]' if default == YES else '[y/N]' if default == NO else '[y/n]'} ")
    if _in := input().lower().strip() or default:
        return YES if _in in ['y', 'yes'] else NO if _in in ['n', 'no'] else yes_or_no(message, default)
    else:
        return default


def deploy_config(template: str, data: Union[HTTPData, StreamData], path: str, args: argparse.Namespace):
    """
    renders template and deploys it
    Parameters
    ----------
    template : str
        the name of the template
    data : HTTPData, StreamData
        the data for the template
    path : str
        the path where to save the config
    args : Namespace
        the current argparse namespace
    """
    rendered_template = jinja_env.get_template(template).render(data=data)

    if args.mock:
        output("\nGenerated config:", style='bold')
        output(rendered_template)
        exit(0)

    if os.path.isfile(path) and \
            yes_or_no(f"The file {filename} already exists, do you want to override it?", default=None) == NO:
        exit(2)

    # write to config file
    output(f"Saving config file to {path!r}", mode="not-quiet")
    with open(path, "w+") as file:
        file.write(rendered_template)

    # run certbot accordingly
    if args.usage == "http" and not args.no_ssl:
        return_code = subprocess.call(["sudo", "certbot", "--nginx", "-d", args.domain])
        if return_code != 0:
            exit(return_code)

    output("The config file was generated.", mode="not-quiet")
    output("The file will be automatically opened in 'nano' for further adjustments.", mode="not-quiet")
    output("Press ENTER to continue.", style="bold")
    input()

    open_in_editor(path)

    if reload_nginx():
        output("Configuration successfully deployed!", style="success")
        output(f"Config file: {path}", style="bold")
    else:
        output(f"Location of the generated file : {path}", style="error")
        output("To reload nginx after the fix run 'sudo systemctl reload nginx'", style="bold")
        exit(3)


def open_in_editor(path) -> bool:
    """
    opens the file in $EDITOR (default is nano not set)

    Parameters
    ----------
    path : str
        the path of the file to be edited

    Returns
    -------
    bool :
        whether edit exited successful
    """
    return subprocess.call(["sudo", os.getenv("$EDITOR", "nano"), path]) or False


def reload_nginx() -> bool:
    """
    if ``nginx -t`` was successful nginx is reloaded

    Returns
    -------
    bool :
        whether nginx was reloaded
    """
    if 0 != subprocess.call(["sudo", "nginx", "-t"]):
        output("'nginx -t' failed possibly due to invalid syntax in a config file. Nginx will not be reloaded.",
               style="error")
        return False
    else:
        if subprocess.call(["sudo", "systemctl", "reload", "nginx"]):
            output("Nginx was successfully reloaded!", style="success")
            return True
        else:
            output("An error occurred while reloading nginx. Run 'sudo journalctl -u nginx.service' to see the logs",
                   style="error")
            return False


def config_files():
    """
    Returns
    -------
    list :
        all the config files
    """
    files = [join(nginx_http_dir, f) for f in listdir(nginx_http_dir) if isfile(join(nginx_http_dir, f))
             and f.endswith(".conf")]
    files += [join(nginx_stream_dir, f) for f in listdir(nginx_stream_dir) if isfile(join(nginx_stream_dir, f))
              and f.endswith(".conf")]
    return files


def get_nginx_conf_file(label: str):
    """
    return the correct config file with path
    exits with error if file does not exist

    Parameters
    ----------
    label : str
        the name of the file
    """
    label = args.file if args.file.endswith(".conf") else args.file + ".conf"
    for conf_file in config_files():
        if re.match(rf'.*/{label}', conf_file):
            return conf_file
    else:
        output(f"File {label} not found!", file=sys.stderr, style="error")
        exit(4)


##
# MAIN
##
if __name__ == '__main__':

    # parse command line arguments
    args = argument_parser.parse_args()

    # check if script is run as root
    if not args.mock and not os.geteuid() == 0:
        output("You must run this script as root", file=sys.stderr, style="error")
        exit(1)

    # output arguments if verbose output
    output("Run with arguments: ", mode="verbose", style="bold")
    output('\n'.join(f'{k}={v}' for k, v in vars(args).items()), mode="verbose")
    output("")

    # parse the config file
    config_file.read(args.config_file)
    template_path: str = config_file["templates"]["path"]
    http_template: str = config_file["templates"]["http"]
    stream_template: str = config_file["templates"]["stream"]
    nginx_http_dir: str = config_file["nginx"]["http"]
    nginx_stream_dir: str = config_file["nginx"]["stream"]

    # set up templating engine environment
    jinja_env = Environment(loader=FileSystemLoader(template_path),
                            lstrip_blocks=True,
                            trim_blocks=True)

    # handle different usages
    if args.usage == "http":
        # create a new http config file
        list_info = f'{"http://" if args.no_ssl else "https://"}{args.domain} -> {args.forwardScheme}:// ( {" | ".join(args.upstreams)} )'
        output(f'Creating config for: {list_info}', mode="not-quiet", style="bold")

        filename = f"{args.label}.conf" if args.label else f"{args.domain}.conf"
        label = f'{args.label if args.label else args.domain}'.strip()

        deploy_config(template=http_template,
                      data=HTTPData(
                          list_info=list_info,
                          domain=args.domain,
                          upstreams=args.upstreams,
                          label=label,
                          backend_name=args.backendName if args.backendName else f'backend_{label}',
                          forward_scheme=args.forwardScheme
                      ), path=f"{nginx_http_dir}/{filename}",
                      args=args)

    elif args.usage == "stream":
        # create a new stream config file
        list_info = f'0.0.0.0:{args.port} -> ( {" | ".join(args.upstreams)} )'
        output(f'Creating config for: {list_info}', mode="not-quiet", style="bold")

        filename = f"{args.label}.conf" if args.label else f"{args.port}.conf"
        label = f'{args.label if args.label else args.port}'.strip()

        deploy_config(template=stream_template,
                      data=StreamData(
                          list_info=list_info,
                          port=args.port,
                          upstreams=args.upstreams,
                          label=label,
                          backend_name=args.backendName if args.backendName else f'backend_{label}'
                      ), path=f"{nginx_stream_dir}/{filename}",
                      args=args)

    elif args.usage == "list":
        # lists all config files and extracts additional info if possible
        files = config_files()
        output("Configuration:", style="bold")
        for file in files:
            with open(file) as f:
                for line in f.readlines():
                    if match := re.match(r'^# list_info: (?P<list_info>.*)$', line):
                        output(f'{file} => {match.group("list_info")}')
                        break
                else:
                    output(f'{file} => ?')
        output("")

    elif args.usage == "edit":
        # opens the specified file and reloads nginx afterwards
        if open_in_editor(get_nginx_conf_file(args.file)):
            reload_nginx()

    else:
        exit(-1)
